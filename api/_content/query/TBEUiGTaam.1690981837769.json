{"_path":"/en/blog/articles/algoritmo-bubble-sort","_dir":"articles","_draft":false,"_partial":false,"_locale":"","_empty":false,"title":"Bubble Sort, sorting algorithm in c++","description":"Bubble Sort is an iterative sorting algorithm, one of the simplest to implement, with a complexity of O(n^2)","img":"/images/articles/bubble-sort.gif","alt":"bubble sort","author":"Giancarmelo","keywords":"Bubble Sort cpp, Bubble Sort, Bubble Sort c++","cAt":"2021-01-25T17:56:57.658Z","uAt":"2021-01-25T20:33:34.535Z","categories":["cpp","algoritmo","tutorial"],"body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"introduction"},"children":[{"type":"text","value":"Introduction"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The BubbleSort algorithm is based on the idea of gradually \"bringing up\" the smallest elements towards the beginning of the set to be sorted, while at the same time \"sinking\" the larger elements towards the end of the set."}]},{"type":"element","tag":"h3","props":{"id":"why-sort"},"children":[{"type":"text","value":"Why sort?"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"It is possible to perform a search, or any operation without sorting, with a certain criterion, a series of data."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Sorting the data facilitates the search if performed with a criterion, for example, if we have an array x = "},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"4,7,8,43,54,62"}]},{"type":"text","value":"; it will be very simple to use algorithms that exploit the so-called "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Divide et impera"}]},{"type":"text","value":" which will reduce the search for a certain value, for example \"54\", to a handful of steps, you can already have at the first step the array "},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"54,62"}]},{"type":"text","value":" and immediately after find the value sought, instead of iterating the entire array from position 0 to position n, where n in our case is 4."}]},{"type":"element","tag":"h2","props":{"id":"strategy"},"children":[{"type":"text","value":"Strategy"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The strategy adopted is to scroll through the sequence to be sorted several times, checking at each step the mutual order of the "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"adjacent"}]},{"type":"text","value":" elements, a"},{"type":"element","tag":"sub","props":{},"children":[{"type":"text","value":"i"}]},{"type":"text","value":" and a "},{"type":"element","tag":"sub","props":{},"children":[{"type":"text","value":"i + 1"}]},{"type":"text","value":", and eventually swapping the unordered pairs."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Example:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A = "},{"type":"element","tag":"span","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"3"}]},{"type":"text","value":","},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"5"}]},{"type":"text","value":",2,4,1"}]},{"type":"text","value":" => "},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"3,"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"5"}]},{"type":"text","value":","},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"2"}]},{"type":"text","value":",4,1"}]},{"type":"text","value":" => "},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"3,2,"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"5"}]},{"type":"text","value":","},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"4"}]},{"type":"text","value":",1"}]},{"type":"text","value":" => "},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"3,2,4,"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"5"}]},{"type":"text","value":","},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"1"}]}]},{"type":"text","value":" ==> "},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"3,2,4,1,5"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A = "},{"type":"element","tag":"span","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"3"}]},{"type":"text","value":","},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"2"}]},{"type":"text","value":",4,1,5"}]},{"type":"text","value":" => "},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"2,"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"3"}]},{"type":"text","value":","},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"4"}]},{"type":"text","value":",1,5"}]},{"type":"text","value":" => "},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"2,3,"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"4"}]},{"type":"text","value":","},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"1"}]},{"type":"text","value":",5"}]},{"type":"text","value":" => "},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"2,3,1,4,5"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A = "},{"type":"element","tag":"span","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"2"}]},{"type":"text","value":","},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"3"}]},{"type":"text","value":",1,4,5"}]},{"type":"text","value":" => "},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"2,"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"3"}]},{"type":"text","value":","},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"1"}]},{"type":"text","value":",4,5"}]},{"type":"text","value":" => "},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"2,1,3,4,5"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A = "},{"type":"element","tag":"span","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"2"}]},{"type":"text","value":","},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"1"}]},{"type":"text","value":",3,4,5"}]},{"type":"text","value":" => "},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"1,2,3,4,5"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"At the end of each of the four scans of the sequence, the largest element of the subset still to be sorted ends up at the end of the sequence, in its definitively correct position, while the still unsorted subsequence is reduced for each pass. "},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\nNow let's see a representation in c++ code.\n"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"br","props":{},"children":[]}]},{"type":"element","tag":"code","props":{"className":["language-cpp"],"code":"#include <iostream>\n\nusing namespace std;\n\nint main(){\n\n  const short size = 20;\n  int elementi[size] = { 0 };\n\n  //populate the elementi array with random values between 3 and 99 (inclusive)\n  for(int i = 0; i< size; i++)\n    elementi[i] = rand() % 100 + 3;\n\n  cout << \"Pre-ordine\\n\";\n  for( auto e : elementi)\n      cout << e << \" \";\n  cout << endl;\n\n  // inizio bubblesort\n  for(int i = 0; i< size -1; i++)\n      for( int j = 0; j< size - 1 - i; j++)\n          if( elementi[j] > elementi[ j + 1])\n            swap( elementi[j], elementi[ j + 1]);\n  // fine bubblesort \n\n  cout << \"Post-ordine\\n\";\n  for( auto e : elementi)\n      cout << e << \" \";\n  cout << endl;\n\n\n  return 0;\n}\n","language":"cpp","meta":""},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"#include <iostream>\n\nusing namespace std;\n\nint main(){\n\n  const short size = 20;\n  int elementi[size] = { 0 };\n\n  //populate the elementi array with random values between 3 and 99 (inclusive)\n  for(int i = 0; i< size; i++)\n    elementi[i] = rand() % 100 + 3;\n\n  cout << \"Pre-ordine\\n\";\n  for( auto e : elementi)\n      cout << e << \" \";\n  cout << endl;\n\n  // inizio bubblesort\n  for(int i = 0; i< size -1; i++)\n      for( int j = 0; j< size - 1 - i; j++)\n          if( elementi[j] > elementi[ j + 1])\n            swap( elementi[j], elementi[ j + 1]);\n  // fine bubblesort \n\n  cout << \"Post-ordine\\n\";\n  for( auto e : elementi)\n      cout << e << \" \";\n  cout << endl;\n\n\n  return 0;\n}\n"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"introduction","depth":2,"text":"Introduction","children":[{"id":"why-sort","depth":3,"text":"Why sort?"}]},{"id":"strategy","depth":2,"text":"Strategy"}]}},"_type":"markdown","_id":"content:en:blog:articles:algoritmo-bubble-sort.md","_source":"content","_file":"en/blog/articles/algoritmo-bubble-sort.md","_extension":"md"}